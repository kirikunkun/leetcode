# 基础知识

* 一个数据域一个指针域（指向下一个链表地址） 最后一个节点指向null

* 单链表

  ![image-20250401234407851](C:\Users\kiri\AppData\Roaming\Typora\typora-user-images\image-20250401234407851.png)

* 双链表![7a7c8f2b6647d9e58a9d18a44411561](D:\大学\WeChat Files\wxid_3x1r31rbe1fg22\FileStorage\Temp\7a7c8f2b6647d9e58a9d18a44411561.png)

* 循环链表![bac8e62e9551bbe4166468c6371971b](D:\大学\WeChat Files\wxid_3x1r31rbe1fg22\FileStorage\Temp\bac8e62e9551bbe4166468c6371971b.png)**可以解决约瑟夫环**
* 可不连续 内存分配机制取决于操作系统内存管理![dec45a4645cd64a2cb087c13e07293f](D:\大学\WeChat Files\wxid_3x1r31rbe1fg22\FileStorage\Temp\dec45a4645cd64a2cb087c13e07293f.png)

* **链表定义**

  ``` //单链表   
  //单链表
  struct ListNode{
  	int val; //存储节点值
  	ListNode *next; //指向下一节点指针 也是链表地址
  	ListNode(int x): val(x), next(NULL){} //节点构造函数
  }
  
  //创建 使用自定义构造函数
  ListNode *head = new ListNode(5);
  //使用非自定义 如果不定义构造函数 就不能初始化赋值
  ListNode *head2 = new ListNode();
  head2->val = 5;
  
  head->next = head2
  head->next != nullptr
  ```

* 删除节点： 直接把删除的前一个节点连到删除后一个节点上 c++需要手动释放内存 其他语言自带

* 添加节点： 需要遍历到需要添加的前一个节点  前一个地址连新的 新的连后一个

  ![b88c9642f698cd245cb67fb6670fdf1](D:\大学\WeChat Files\wxid_3x1r31rbe1fg22\FileStorage\Temp\b88c9642f698cd245cb67fb6670fdf1.png)

  

# 移除链表

## 思路

* 可以在原链表直接删除 
* 可以创建虚拟头节点 因为头节点和中间节点删除规则不一样 为了一样 用于增和删

## Tips

* 注意要从当前指针开始 不能从curr->next开始 要不没法找到

* 需要创一个cur临时指针用来遍历 head用来存储最开始的 不能用头节点遍历 

* cur=head/duumy head 就是要删的上一个 不能是要删的那个

* 当前这个指针不能为空 就是要调用node->next 这个node 不能为空否则报错 next无所谓

* ``` 
  while(cur->next != NULL){
  
  ​      if(cur->next->val == val){
  
  ​        cur->next = cur->next->next;
  
  ​      }
  
  ​      else{
  
  ​        cur = cur->next; //注意这一块应该写在else里 不应该写在外面 写外面会漏删一些连续的 而且也放弃了对cur->next->next是否为空的检查 就会报错
  
  ​      }
  
  ​      
  
  ​    }
  ```

## 题目

### 简单

\-[ X ] [203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/description/)



# 设计链表

## 思路

## Tips

* 用虚拟头节点可以快速找到第一个在哪 因为没告诉你第一个的地址

* 如果你有一个成员变量叫 `size`，应该使用 `this->size` 或 `_size`（如果你遵循下划线命名约定）来明确指定 用_是为了不会和其他c++库里的命名冲突

* 注意在私有部分对成员进行声明

* 注意删除或者其他的时候 可能删除第一个 所以cur最好等于dummyhead  需要判断cur是dummy 还是dummy-》next 看是否有情况是需要处理dummy-next

* ```cpp
    delete tmp;
          //delete命令指示释放了tmp指针原本所指的那部分内存，
          //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
          //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
          //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
    tmp=nullptr;
  ```

* 注意不要用size -1 size为0会有问题
* addat 应该允许等于size

## 题目

### 中等

\-[ X] [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)

