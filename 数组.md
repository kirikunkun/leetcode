# 基础知识

- vector底层时array实现 但是vector其实更像容器 它可以增删改查 array不行 array是固定的 vector是动态的 但是array更高效
- 容器本质上是模板 无需手动实现底层数据结构就可以组织处理梳理
- **数组是存放在连续内存空间上的相同类型数据的集合。**
- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**
- **数组元素不能删只能覆盖**



# 二分法

找到有序数组中的某个值

## 思路

一个指针在左一个指针在右 每一次判断mid是否大于小于或等于想要值 然后移动左右指针

## Tips

* 注意边界处理要统一【left，right】or【left，right）贯彻while条件和middle值 不遵循可能陷入死循环 选择哪个关键是要看你需要两个指针相等的值 还是需要他们没相等的左闭区间的mid值

* 在二分查找算法中，计算中点的正确公式是：mid = left + (right - left) / 2 避免因为left right特别大 加在一起超过了 int 的范围

* **前提是数组为有序数组**，**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的

* 时间复杂度：O（log n） 每次将问题规模减半 进行t次
  $$
  n \times \left(\frac{1}{2}\right)^t = 1 \implies \frac{n}{2^t} = 1 \implies 2^t = n，两边取对数得 t = \log_2 n
  $$
  
* 空间复杂度：O（1）二分查找仅需维护几个变量（如 `left`、`right`、`mid`），无论输入规模 *n* 多大，这些变量的数量恒定，不随 *n* 增长而增加

  

## 题目

### 简单

\- [ √ ] [704 简单 二分查找](https://leetcode.cn/problems/binary-search/)

\- [ X ] [35简单 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

### 中等

\- [ X ] [34中等 排序数组查找元素第一个和最后位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

1. 注意三种情况：在两头（注意不能直接用第一个元素或最后一个元素判断 空数组容易超出边界） 找不到 以及找得到



# 移除元素（双指针 快慢指针法）

移除数组中某个元素 注意数组中的元素不能删除只能覆盖 只能在原数组上改 即空间复杂度是O（1）

## 思路

双指针法  快慢指针 快指针进行循环（遍历整个数组） 如果当前值不等于删除值 赋值给慢指针 慢指针++

+ 快指针：找到用来替换的元素 需要跳过就跳过
+ 慢指针：指向需要更新的位置
+ 是erase函数的底层逻辑

## Tips

+ 其实内存大小没有变 但是返回的数组大小需要-- vector是包装过的array 也会这么做
+ 时间复杂度：O(n)  因为只用一次循环 earse函数时间复杂度也是
+ 空间复杂度：O(1)

## 题目

### 简单

\- [ √ ] [27简单 移除元素](https://leetcode.cn/problems/remove-element/description/)

\- [ X ] [844简单. 比较含退格的字符串 ](https://leetcode.cn/problems/backspace-string-compare/description/)

+ 从后往前 先循环一个 再循环另一个 最后在有效位置对比



# 有序数组平方（双指针法两端）

给有序数组平方排序

## 思路

因为数组是递增的 而且有负数 所以绝对值后应该是一边递减 一边递增 可以放一个指针在一个前和一个后  然后对比两端的指针所指平方大小

## Tips

* 时间复杂度：O(N) 最多循环n次
* 暴力解法是先遍历得到平方后的数组（n） 然后再快排（nlogn） 

## 题目 

### 简单

\- [ X ] [977. 有序数组的平方 简单](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)



# 长度最小的子数组（滑动窗口）

返回长度最小的数组大小

## 思路

需要两个指针 一个代表窗口的起始位置 一个是终止位置 

如果对起始位置做遍历 那 找终止位置每一个还要进行循环 （暴力解法） 需要两个循环

但是**如果只对终止位置做遍历 起始指针动态移动** 就只用循环一次

**当我们发现集合里面的元素和大于等于target 再移动起始位置**

## Tips

* 注意起始指针需要持续移动（如果一直大于target） 所以中间应该用while
* 时间复杂度：O(N)
* 空间复杂度：O(1) 

## 题目

### 中等

\-[ X ] [209.中等 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)



# 螺旋矩阵

边长为n的 顺时针螺旋排列 给出矩阵（从左到右 从上到下)

## 思路

* 边界要一样规则 要不判断条件很多 每一圈都是左闭右开
* 需要转n/2圈 因为每往里一层会-2的边长
* 每一次循环要分别遍历四个边 左闭右开 用每一层的边长n来计算 【i] [j] = xx

## Tips

* 时间复杂度：O(N^2) 一共有这么多元素 每个都只被遍历一次
* 空间复杂度：O(1) 需要返回的数组不算在空间复杂度里 其他变量都是常量不随n变化

## 题目

### 中等

\-[ X ] [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/description/)

* 注意xy别弄反 先变y 也就是列

# 区间和（前缀和）

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

## 思路

* 暴力解法当然是一个一个遍历
* 创建从0开始往后相加的数组 每一个存 0-1 0-2 0-3.。。
* 取啥减去前面的和 

## Tips

* 注意减的是a-1

## 思路

### ACM模式

* **输入输出头文件 \#include <iostream> 注意没有；**

* 数组 #include <vector> 注意没有；

* using namespace std; 在 C++ 中，**命名空间**（Namespace）用于 **防止命名冲突**。标准库的所有内容（如 `cout`、`vector`、`string`）都定义在 `std` 命名空间里

* int main()

* cin >> n;

* 注意还得处理每一次输入 可以把输入赋值给你想要的变量 比如 cin>>num 输入的数值就是num

* 用scanf 和 printf读取大量数据速度更快   scanf("%d", &vec[i]); 读取一个int 存入vec[i]  **`%d`**：表示读取一个 `int` 类型整数。**`&变量`**：取变量地址，`scanf` 需要知道数据存储的位置。

* ```cpp
   while (~scanf("%d%d", &a, &b))
  ```

* **`~` 是取反运算符**，`~scanf` 表示“只要 `scanf` 不返回 `-1`（即未遇到文件结束符 `EOF`），循环继续”。读取 **两个整数**，分别存入 `a` 和 `b`

* ```cpp
  printf("%d\n", sum);
  ```

* 输出并换行 **注意不用写&**

\-[√] [58. 区间和（第九期模拟笔试）](https://kamacoder.com/problempage.php?pid=1070) 

	* 主要是语法

# 开发商购买土地（前缀和）

分成了n * m个连续的区块 每个区域不同权值 只能横向或纵向分 分给ab 需要差距最小 输出最小差距

## 思路

* 先存数组
* 计算行和列和以及总-行和列 跟区间和一样存相加 然后枚举分割线 

## Tips

* 时间复杂度：O(N^2)
* 注意计算另一个的时候累加清空

## 题目

### ACM模式

\-[ X] [44. 开发商购买土地（第五期模拟笔试）](https://kamacoder.com/problempage.php?pid=1044)

* 注意后面分割线只能前缀和枚举
