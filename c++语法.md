# 数组

+ 注意数组是{，} 不是【，】

+ 时刻注意数组不能越界，注意用例的空数组

+ 注意 `nums.size()` 返回 `size_t`（无符号整数） 所以当size=0时 0-1会变成超级大正数导致越界 所以for循环边界条件尽量不要用<= .size()-1 用<size() 要不然会越界

+ ‘ ’表示字符 “ ”表示字符串

+ vector<int>& nums &是引用 表示对nums的修改会直接影响外部原始量 避开了拷贝消耗 省略了&传递是向量的副本 修改不会影响原数据

+ for(int i = 0, j = nums.size() - 1; i <= j;) 可以没有更新语句 但是需要；占位

+ ```cpp
  result = INT32_MAX; //可以用来表示这个值是最大值
  ```

* | **`.size()`**   | 所有标准库容器（如 `vector`、`string`、`list` 等） | 返回元素数量（通用接口） | 更推荐使用（符合泛型编程习惯） |
  | --------------- | -------------------------------------------------- | ------------------------ | ------------------------------ |
  | **`.length()`** | 仅用于 `std::string`                               | 返回字符串长度（字符数） | 本质是 `.size()` 的别名        |

* 注意+=没有空格中间

* 二维数组  vector<vector<int>> res(n, vector<int>(n, 0));  初始化了一个 n*n 矩阵 res【i】【j】 传入值 输出其实就是[[1,2,3],[2,3,4]] 这种 第一个是第一行 第二个是第二行

  

# 链表

* 以下划线开头的变量名（如 `_dummyHead`、`_size`）通常表示它们是类的**私有成员**
* 注意结构体末尾要有分号
* 注意==22==ERROR: AddressSanitizer: heap-use-after-free 访问已经删除的内存 不能先初始化一个链表 然后把其他链表整个赋给他 可以直接设为空再赋值 临时指针无需new直接初始化为nullptr，避免内存泄漏
* 注意while（pos++ 这个循环会先使用pos 然后再自增
* 建议不要把p++写while上 因为如果p等于0就会立即停止 n--可以